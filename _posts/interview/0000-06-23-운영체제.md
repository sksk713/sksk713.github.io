---
layout: post
title: "운영체제 면접 질문"
author: "SangKyenog Lee"
tags: Interview-Questions
---

프로세스와 스레드의 차이
<details markdown="1">
<summary>답변</summary>

`프로세스는 메모리에 올라와 실행 중인 프로그램의 인스턴스이며 운영체제로부터 각 프로세스마다 독립적인 코드, 데이터, 스택, 힙 영역을 할당 받습니다. 스레드는 프로세스 내에서 실행되는 하나의 흐름이며, 스레드들은 코드, 데이터, 힙 영역을 공유하고 각 스레드마다 독립적인 스택 영역을 할당받습니다.`

</details>

<br>

멀티 스레드란?
<details markdown="1">
<summary>답변</summary>

`멀티 프로세스보다 멀티 스레드가 메모리 공간과 시스템 자원 소모가 적습니다. 데이터 섹션 또는 힙 영역으로 스레드 간의 통신이 가능하고 컨텍스트 스위칭이 발생하게 되면 스택영역만 처리하면 되기 때문입니다. 하지만 스레드 간 자원을 공유하기 때문에 동기화 작업이 필요합니다. 또한 공유로 인해 하나의 스레드가 종료되면 전체 스레드가 종료됩니다.`

</details>

<br>

멀티 프로세스의 단점은?
<details markdown="1">
<summary>답변</summary>

`프로세스 생성할때마다 시스템 콜이 발생하고 컨텍스트 스위칭이 발생하면 스택만 처리하면 되던 멀티 스레드와는 달리, 모든 영역이 독립적인 영역이기 때문에 모두 다 처리를 해야합니다. 또한 통신에서도 공유하는 영역이 하나도 없어서 IPC를 통해 통신을 해야해서 오버헤드가 커집니다.`

</details>

<br>

Context Switching이 무엇인가?
<details markdown="1">
<summary>답변</summary>

`어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)를 교체하는 작업을 말합니다.`

</details>

<br>

뮤텍스와 세마포어에 대해서 설명해주세요
<details markdown="1">
<summary>답변</summary>

`뮤텍스는 공유 자원을 여러 스레드가 접근하는 것을 막는 것이고 세마포어는 공유자원에 접근할 수 있는 스레드 및 프로세스의 수를 컨트롤 해서 접근을 제한하는 것을 말합니다. 둘의 차이는 동기화의 대상인데 뮤텍스는 한개이고 세마포어는 하나 이상일 경우에 사용하며 이에 따라 뮤텍스는 한개이므로 소유가 가능해서 소유주가 해당 자원에 대한 책임을 지지만, 세마포어는 단지 접근 가능한 스레드 및 프로세스 수를 컨트롤 하는 것이기 때문에 소유의 개념이 없습니다.`

</details>

데드락이 무엇인가?
<details markdown="1">
<summary>답변</summary>

`두 개 이상의 서로 다른 프로세스가 상대방의 작업이 끝나기만을 기다리는 상태를 데드락(교착상태)라고 합니다.`

</details>

<br>

데드락의 발생조건을 설명해보세요
<details markdown="1">
<summary>답변</summary>

`데드락은 네 가지의 조건이 모두 성립할때 발생합니다. 첫번째로 상호배제입니다. 상호배제는 하나의 자원을 하나의 프로세스만 사용이 가능함을 말합니다. 두번째로 점유 대기입니다. 점유 대기란 프로세스는 하나 이상의 자원을 점유하며, 다른 프로세스가 소유주인 자원을 사용하기 위해 대기중이어야 합니다. 세번째로 비선점입니다. 프로세스의 작업이 끝나지 않고서는 다른 프로세스의 자원을 뺏을 수 없습니다. 마지막으로 순환 대기입니다. 순환대기는 프로세스들이 점유한 자원과 대기중인 자원의 집합이 순환형으로 이루어져 있는 것을 말합니다.`

</details>

<br>

데드락을 어떻게 해결할 수 있나?
<details markdown="1">
<summary>답변</summary>

`데드락을 예방하거나 회피하거나 회복하는 방법이 있습니다. 예방은 사실 실질적으로 하게 되면 자원낭비가 심하여 추천되지 않습니다. 그 중에 자원 요청 순서를 번호를 정하여 순환 대기를 부정하는 것이 가장 낫습니다. 회피는 시스템이 항상 safe state에 있도록 자원을 할당하는 은행원 알고리즘이 있습니다. 하지만 사전에 파악해야할 정보들이 많고 자원 이용도가 하락한다는 단점이 있습니다. 회복은 데드락을 발생시킨 프로세스를 종료시키거나 해당 데드락에 관련된 프로세스들을 종료시키는 방법입니다.`

</details>

<br>

동시성과 병렬성의 차이점을 설명해주세요
<details markdown="1">
<summary>답변</summary>

`동시성과 병렬성 모두 여러 개의 작업을 동시적으로 실행하는 방식인데, 동시성은 하나의 코어에 여러개의 쓰레드가 많은 작업을 처리하는 것처럼 보이는 것이고, 병렬성은 두개 이상의 코어가 실제로 한번에 많은 일을 처리하는 것입니다. 동시성은 소프트웨어 병렬성은 하드웨어적인 성질입니다.`

</details>

<br>

시분할에 대해서 설명해주세요
<details markdown="1">
<summary>답변</summary>

`1개 코어가 여러개의 작업 처리 대상들을 시간을 쪼개어 할당하는 것을 말합니다.`

</details>

<br>

스케쥴링은 무엇인가?
<details markdown="1">
<summary>답변</summary>

`운영체제의 가장 중요한 업무는 실행중이거나 실행되어야 할 프로세스들을 관리하는 일입니다. 운영체제가 프로세스에 필요한 자원을 할당을 하고 관리하는 과정을 스케줄링이라고 부릅니다.`

</details>

<br>

스케쥴링을 하는 이유는 무엇인가?
<details markdown="1">
<summary>답변</summary>

`CPU의 효율을 극대화시키기 위해 합니다. 만약 어떤 프로세스가 실행 중, 입출력 요청에 의해 wait 됐을 때,다시 ready 상태가 될 때까지 기다리는 것은 비효율적입니다. 최대한 많은 프로세스를 실행하여 CPU가 쉬지 않도록 해야합니다.`

</details>

<br>

비선점과 선점 알고리즘의 차이는 무엇인가?
<details markdown="1">
<summary>답변</summary>

`실행 중인 프로세스의 자원을 도중에 뺏을 수 있으면 선점 알고리즘 끝날때까지 기다려야한다면 비선점 알고리즘입니다.`

</details>

<br>

기아 현상을 막을 수 있는 방법은 무엇인가?
<details markdown="1">
<summary>답변</summary>

`Aging을 사용하여 막습니다. 기아 현상은 우선순위가 낮은 프로세스가 우선순위가 높은 프로세스에게 계속 순서를 뺏겨서 발생하는데 오래 기다린 프로세스의 우선순위를 높여준다면 해결할 수 있습니다.`

</details>

<br>

swapping을 하는 이유와 이점은?
<details markdown="1">
<summary>답변</summary>

`swapping은 지금 실행해야 할 프로세스가 있는데 메모리 공간이 부족하여 기존의 사용하지 않을 프로세스를 메모리 공간에서 디스크로 내보내는 것을 말합니다.`

</details>

<br>

swapping과 가상메모리의 차이는?
<details markdown="1">
<summary>답변</summary>

`swapping은 프로세스 전체를 메모리에서 내보내지만 가상메모리는 page단위로 내보냅니다.`

</details>

<br>

페이징과 세그멘테이션의 차이를 설명해보세요
<details markdown="1">
<summary>답변</summary>

`분할하는 방법에서 차이가 있습니다. 페이징은 프로그램을 같은 크기로 자르기 때문에 내부단편화가 발생합니다. 세그멘테이션은 의미 단위로 자릅니다. 같은 의미끼리 모여있어 공유나 보안면에서 페이징보다 우수하지만, 외부 단편화가 발생하는 단점이 있습니다.`

</details>

<br>

내부 단편화와 외부 단편화의 차이에 대해 설명해주세요
<details markdown="1">
<summary>답변</summary>

`내부 단편화는 실행해야 할 프로그램의 크기가 분할된 메모리의 크기보다 작은 것을 말합니다. 따라서 남는 공간이 발생하고 이것이 내부 단편화입니다. 외부 단편화는 실행해야 할 프로그램의 크기가 분할된 메모리의 크기보다 큰 것을 말합니다. 외부 단편화는 곳곳에 홀이 생기기 때문에 내부 단편화보다 메모리 낭비가 심해집니다.`

</details>

<br>

불연속으로 할당된 메모리를 어떻게 실행시킬 수 있는지?
<details markdown="1">
<summary>답변</summary>

`각 페이지의 정보가 page table에 저장되어 있고, page table에는 base와 offset이 존재합니다. page table은 연속적으로 보이지만 실제 물리 메모리에 올라가있는 곳은 제 각각이기 때문에 불연속적이어도 page table을 보고 찾아갈 수 있기 때문에 실행 가능합니다.`

</details>

<br>

TLB가 무엇인가?
<details markdown="1">
<summary>답변</summary>

`TLB는 데이터에 접근하려면 page table과 물리 메모리 접근까지 두번의 과정이 필요한데 TLB에 가상 페이지 번호가 저장되어 있다면 page table을 참조할 필요없이 바로 물리 메모리로 접근할 수 있습니다.`

</details>

<br>

blocking과 non-blocking에 대해서 설명해주세요
<details markdown="1">
<summary>답변</summary>

`둘은 어떤 함수를 호출했을 때, 제어권이 돌아오는 시점에서 차이가 있습니다.. blocking은 함수를 호출하면 호출된 함수의 결과값이 준비되었을 때 제어권을 반환하며, 논 블로킹은 호출된 즉시 반환할 수 있는 값과 함께 제어권이 반환되며 값을 언제줄 지 모르기 때문에 지속적으로 polling을 해줘야 합니다.`

</details>

<br>

동기와 비동기의 차이는 무엇인가요?
<details markdown="1">
<summary>답변</summary>

`동기는 제어권과 데이터의 반환시점이 동일하며, 비동기는 제어권과 데이터의 반환시점이 동일하지 않다. 동기는 시스템콜이 발생하면 해당 시스템콜이 끝날때까지 대기하고, 비동기는 기다리지 않고 시스템콜 인터럽트가 오면 그때 결과물을 받아온다.`

</details>

<br>
