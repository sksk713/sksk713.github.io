---
layout: post
title: 03.프로세스와 스레드
author: "SangKyeong Lee"
tags: Operating-System
---

# 프로세스
---
프로그램은 저장장에 저장되어 있는 정적인 상태를 말하고, 프로세스는 실행을 위해 메모리에 올라온 동적인 상태를 말한다.

한마디로 프로그램을 작성해서 실행하면 그것이 `프로세스`라고 할 수 있다.

프로그램이 실행되면 운영체제는 프로그램을 메모리의 적당한 위치로 가져오고, 프로세스 제어 블록(Process Control Block)을 만든다. 여기에는 프로세스를 처리하는데 필요한 다양한 정보가 들어 있다.

![11](/assets/os/11.png)

> 프로그램이 프로세스가 되었다는 것은 운영체제로부터 프로세스 제어 블록이 만들어졌다는 의미!

<br>

# 프로세스의 상태
---

![12](/assets/os/12.png)

생성 상태
- 프로그램을 메모리에 가져와 실행 준비가 완료된 상황이며, 프로세스 제어 블록이 생성됨

준비 상태
- 실행을 기다리는 모든 프로세스가 자기 차례를 기다리는 상태이며, 실행될 프로세스를 CPU 스케줄러가 선택(dispatch)한다.

실행 상태
- 선택된 프로세스가 타임 슬라이스를 얻어 CPUfmf 사용하는 상태고 프로세스 사이에 문맥 교환(Context switching)이 발생함
- 프로세스가 timeout이 되면 다시 준비상태로, exit하면 완료 상태로, block되면 대기 상태로 된다.

대기 상태
- 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될때까지 대기한다. wakeup되면 다시 준비 상태로 간다.

완료 상태
- 사용하던 모든 데이터가 정리되고, 메모리 삭제, 프로세스 제어 블록이 삭제된다.
- 비정상적으로 종료되면 강제 종료 직전의 메모리 상태를 저장 장치로 옮기는데 이것을 `코어 덤프`라고 한다. 

<br>

# 프로세스 제어 블록(PCB)
---
PCB는 프로세스를 실행하는데 필요한 중요한 정보를 보관하는 자료구조이며, 모든 프로세스는 고유의 프로세스 제어 블록을 가진다.

![13](/assets/os/13.png)

## 포인터의 역할
입출력이 완료되기를 기다리는 프로세스는 대기 상태로 모이는데, 이것들을 같은 입출력을 요구한 프로세스끼리 모아놓을때 포인터를 사용한다. 

각 프로세스 제어 블록을 대기 큐에 넣고 인터럽트가 도착하면 해당 입출력 대기 큐에 있는 프로세스 제어 블록을 찾아서 준비 상태로 바꾸고 준비 큐로 이동시킨다.

<br>

# 문맥 교환(Context Switching)
---
문맥 교환은 CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다. 

다시 말해 두 프로세스 제어 블록 중에 하나는 지금까지의 작업 내용을 저장하고, 다른 하나는 해당 프로세스 제어 블록의 내용으로 CPU를 세팅한다.

## 문맥 교환 절차
![14](/assets/os/14.png)

문맥 교환은 프로세스가 주어진 시간을 다 사용하거나, 인터럽트가 걸렸을 때 발생한다. 인터럽트는 예를 들어 현재 실행중인 프로세스가 자신에게 주어진 메모리 공간을 넘어가려 할 때, 인터럽트 관리 프로세스를 실행 상태로 만들어서 해당 프로세스를 강제로 종료하고 인터럽트 처리를 마친다.

<br>

# 프로세스 구조
---
프로세스 구조는 코드 영역, 데이터 영역, 스택영역으로 구분된다

> 데이터 영역은 일반 데이터 영역과 힙 영역으로 나뉜다.

## 코드 영역
코드 영역은 프로그램의 본문이 기술되며, 텍스트 영역이라고도 한다. 탑재된 코드는 읽기 전용으로 처리됨

## 데이터 영역
데이터 영역은 변수나 파일 등의 각종 데이터를 모아놓는다.

## 힙 영역
프로세스가 실행되는 동안 만들어지는 영역으로, 크기가 동적으로 변하는 영역이다.

## 스택 영역
스택 영역은 운영체제가 프로세스를 실행하기 위해 필요한 데이터(지역 변수)를 모아놓은 곳이다. 함수를 호출하게 되면 지속적으로 쌓이고 언젠가 다시 제자리로 돌아온다.

![18](/assets/os/18.png)

<br>

# 프로세스 생성과 복사
---
프로세스는 프로그램을 실행하면 새로 생성된다. 운영체제는 메모리 데이터 영역과 스택 영역을 확보한 후, 프로세스를 실행한다.

## fork()
fork() 시스템 콜은 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수이다.

새로 복사를 하게 되면 기존 프로세스는 부모 프로세스, 새로 생긴 프로세스는 자식 프로세스가 된다.

### fork() 호출 과정

![15](/assets/os/15.png)

프로세스를 복사하면, 프로세스 제어 블록의 대부분이 복사 되지만 일부분이 변경된다
- 프로세스 구분자(PID)가 바뀐다
- 메모리 위치가 다르므로, 메모리 관련 정보가 바뀐다.
- 부모 프로세스 구분자(PPID), 자식 프로세스 구분자(CPID)가 바뀐다.

### fork() 장점
1. 프로세스의 생성 속도가 빠르다.
- 하드 디스크로부터 프로그램을 새로 가져오지 않고 기존 메모리에서 복사하기 때문에

2. 추가 작업 없이 자원을 상속할 수 있다.
3. 시스템 관리를 효율적으로 할 수 있다.
- 자식 프로세스가 종료되면, 사용하던 메모리 영역, 파일, 하드웨어 정리를 부모 프로세스가 맡아서 해결한다.

<br>

# 프로세스의 전환
---
fork()를 사용해 프로세스를 복사한 후, 해당 프로세스를 새로운 프로세스로 바꾸는 함수 exec()에 대해서 알아보자.

## exec()
exec()를 사용하는 목적은 프로세스의 구조체를 재활용하기 위함이다.

여기서 PCB를 만들고, 메모리를 확보하고, 종료 후에 메모리를 청소하기 위해 부모-자식 관계를 만들 필요 없이 이미 만들어진 것을 사용하면 되므로 편리하다.

![16](/assets/os/16.png)

코드 영역, 데이터 영역이 새롭게 바뀌고 스택 영역은 모두 리셋된다.

<br>

# 프로세스의 계층 구조
---
![17](/assets/os/17.png)

위의 그림처럼, 커널이 처음 메모리에 올라와 부팅이 되면 여러 개의 프로세스를 만드는데 그중 init 프로세스는 모든 프로세스의 출발점이 된다.

## 계층 구조의 장점
1. 여러 작업의 동시 처리
2. 용이한 자원 회수

<br>

# 고아, 좀비 프로세스
---
부모 프로세스는 자원을 회수하기 위해 자식 프로세스가 끝날 때까지 기다려야 한다.

만일 부모 프로세스가 먼저 종료되거나, 자식 프로세스가 비정상적으로 종료되어 부모 프로세스에 연락이 안되는 경우가 있다.

부모 프로세스가 먼저 죽은 경우, 남아있는 자식 프로세스를 `고아 프로세스`라고 한다
- 부모가 먼저 죽은 경우 init을 새로운 부모 프로세스로 정한다.

자식 프로세스가 죽었지만 부모 프로세스가 회수 하지 않는다면, 이때 자식 프로세스를 `좀비 프로세스`라고 한다.
- wait() 시스템 콜을 사용해서 회수를 할 수 있도록 처리한다.

<br>

# 스레드
---
프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위이다.

> 여러 개의 스레드가 모여 프로세스를 이루고 프로세스 들이 모여서 Job이 된다.

프로세스들 간에는 서로 영향이 크지 않지만 스레드 간에는 서로 영향력이 더 크다.

<br>

# 멀티스레드
---
멀티스레드는 프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄이는 기법이다.

## 멀티프로세싱
멀티프로세싱은 CPU를 여러 개 사용해서 여러 개의 스레드를 동시에 처리하는 것을 말한다.

## 멀티스레드 구조
fork() 시스템 콜을 이용해서 같은 프로세스를 생성했을 때, 코드 영역과 데이터 영역의 일부가 메모리 영역에 중복되어 존재하기 때문에 낭비가 될 수 있다.

스레드는 이러한 낭비를 막기 위해서 두개의 프로세스를 만드는 대신 하나의 프로세스에서 코드, 데이터 등을 공유하면서 여러 개의 일을 하나의 프로세스에서 처리하는 것이다.

![19](/assets/os/19.png)

## 멀티스레드 장단점
프로세스 내 공유가 가능한 부분을 제외하고 실행과 관련된 부분을 스레드로 나누어 관리하면 중복 사용을 피함으로써 낭비를 막을 수 있다.

장점
1. 응답성 향상
2. 자원 공유
3. 효율성 향상
4. 다중 CPU 지원

단점
인터넷 익스플로러는 새로운 창을 띄울 때 스레드를 사용하고, 크롬은 새로운 프로세스를 사용한다. 따라서 익스플로러는 하나의 스레드에서 문제가 발생하면 모두 종료되며, 크롬은 익스플로러보다 조금 더 영향이 적다

## 멀티스레드 모델
커널 스레드: 커널이 직접 생성하고 관리하는 스레드<br>
사용자 스레드: 라이브러리에 의해 구현된 일반적인 스레드

사용자 스레드가 커널 스레드를 사용하려면 시스템 콜을 사용해야 한다.

사용자 스레드 (1 to N)
- 라이브러리가 커널이 지원하는 스케줄링이나 동기화 기능을 대신 해주고 해당 라이브러리가 커널이 하는 일을 대신 해주기 때문에 하나의 커널에 여러 개의 스레드가 연결된다.
- 여러 개의 스레드가 하나의 커널 스레드와 연결되기 때문에 커널 스레드가 대기 상태에 들어가면 모든 사용자 스레드가 대기해야한다.

커널 스레드 (1 to 1)
- 커널 레벨에서 모든 작업을 지원하기 때문에 멀티 CPU를 사용할 수 있고, 하나의 스레드가 대기 상태에 있어도 다른 스레드는 작업을 계속할 수 있다. 하지만 문맥 교환때문에 오버헤드가 발생하여 조금 느리다.

멀티레벨 스레드 (M to N)
- 위의 두가지의 장단점을 모두 가지고 있다. 속도가 중요할 때는 사용자 스레드로 안정적이어야 할때는 커널 스레드로 움직일 수가 있다.