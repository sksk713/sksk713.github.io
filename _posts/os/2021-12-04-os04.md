---
layout: post
title: 04.CPU 스케줄링
author: "SangKyeong Lee"
tags: Operating-System
---

# 스케줄링
---
CPU 스케줄러는 여러 프로세스 상황을 고려하여 CPU와 시스템 자원을 어떻게 배정할지 결정하는 일을 말한다.

<br>

# 고수준 스케줄링(high level scheduling)
---
고수준 스케줄링은 `장기 스케줄링` 또는 `작업 스케줄링`이라고도 하며 시스템 내의 전체 작업 수를 조절하는 것을 말한다.

여기서 작업은 1개 또는 여러 개의 프로세스로 이루어지며, 해당 작업을 시스템이 받아들일지 또는 거부할지를 결정핟나.

<br>

# 저수준 스케줄링(low level scheduling)
---
저수준 스케줄링은 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정하는 일을한다.

프로세스 상태에 대한 것이면 모두 저수준 스케줄링으로 보면 되고, 아주 짧은 시간에 일어나기 때문에 `단기 스케줄링`이라고도 한다.

> 오늘날의 스케줄러는 대부분 저수준 스케줄링으로 구성되어 있다.

<br>

# 중간 수준 스케줄링(middle level scheduling)
---
중간 수준 스케줄리은 고수준 스케줄링이 전체 프로세스 수를 조절하지만, 이미 활성화 된 프로세스로 인해 문제가 발생할 수 있다. 그때 중간 수준 스케줄링이 중지와 활성화를 통해 시스템 과부하를 막는다.

![20](/assets/os/20.png)

<br>

# 스케줄링의 목적
---
CPU 스케줄링의 원래 목적은 모든 프로세스가 공평하게 작업하도록 하는 것이다.

공평성
- 모든 프로세스가 자원을 공평하게 배정받아야 하며, 특정 프로세스가 배제되어서는 안된다.

효율성
- 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링을 하고, 유휴 자원을 사용하려는 프로세스에느 우선권을 줘야 한다.

안정성
- 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원을 보호해야 한다.

확장성
- 프로세스가 증가해도 시스템이 안정적으로 작동하도록 해야 한다.

반응 시간 보장
- 응답이 없는 경우, 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다.

무한 연기 방지
- 특정 프로세스의 작업이 무한히 연기되어서는 안된다.

<br>

# 선점형 스케줄링
---
어떤 프로세스가 CPU를 할당받아 실행중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 방식이지만, 문맥 교환이 발생하여 오버헤드가 많다.

빠른 응답 시간을 요구하는 대화형 시스템이나 시분할 시스템에 적합하며, 대부분의 저수준 스케줄러는 선점형 스케줄링 방식을 사용한다.

<br>

# 비선점형 스케줄링
---
어떤 프로세스가 실행 상태에 들어가서 CPU를 사용하면 그 프로세스가 종료되거나 자발적으로 대기 상태에 들어가기 전에는 계속 실행된다. 문맥 교환이에 의한 오버헤드가 적다.

하지만, 사용 시간이 긴 프로세스 때문에 다른 프로세스들은 오랫동안 기다려야 돼서 처리율이 떨어진다.

## 스케줄링 우선순위
---
![21](/assets/os/21.png)

<br>

# 준비 상태의 다중 큐
---
프로세스마다 우선순위가 다르기 때문에 매번 모든 프로세스 제어 블록을 뒤져서 찾는 것은 낭비가 아닐 수 없다.

이를 해결하기 위해 우선순위 별로 큐를 만들어서 준비 상태의 프로세스를 관리한다.

![22](/assets/os/22.png)

<br>

## 우선순위 방식
---
고정 우선순위 방식
- 운영체제가 프로세스에 우선순위를 부여하면 절대 우선순위가 바뀌지 않는다. 변화에 대응하기 힘들어져 작업 효율이 떨어짐

변동 우선순위 방식
- 작업 중간에 우선순위가 변할 수 있는데 구현하기가 쉽지 않은 문제가 있다.
- 어떤 자원을 사용할 때, 해당 프로세스가 조금 더 빨리 끝내야할 필요가 있다면 `반전 우선순위(Priority inversion)`을 통해 낮은 우선순위를 높은 우선순위로 바꾼다.

<br>

# 대기 상태의 다중 큐
---
대기 상태에서도 다중 큐를 사용하는데 준비 상태와는 달리 대기 상태에서는 입출력 별로 큐를 만들어서 관리한다. 간단한 예시로 하드디스크 작업이 끝났으면 하드디스크를 사용해야 하는 프로세스만 찾으면 되기 때문이다.

![23](/assets/os/23.png)

<br>

## 준비 상태 큐와 대기 상태 큐의 차이점
준비 큐는 한번에 하나의 프로세스를 꺼내 CPU에 할당하고, 대기 큐는 여러 개의 프로세스 제어 블록을 동시에 꺼내 준비 상태로 옮긴다.

동시에 끝나는 입출력이 많아서, 여러 개의 인터럽트가 한꺼번에 처리되고 이런 인터럽트를 처리하기 위해 `인터럽트 벡터`라는 자료 구조를 사용한다.

`인터럽트 벡터`에는 입출력 정보와 처리 방법이 담겨 있고, 이 정보에 따라 완료된 제어 블록들이 모두 준비 상태로 이동하게 된다.

![24](/assets/os/24.png)

<br>

# 스케줄링 알고리즘
---
비선점형
- FCFS, SJF, HRN

선점형
- 라운드 로빈, SRT, 다단계 큐, 다단계 피드백 큐

둘다
- 우선순위 스케줄링

![25](/assets/os/25.png)

<br>

## FCFS(First Come First Served) 스케줄링
---
FCFS는 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식으로, 선입선출 스케줄링이라고도 한다.

![26](/assets/os/26.png)

비선점형 방식이기 때문에, 하나의 프로세스가 끝나야 다음 프로세스를 실행할 수 있고, 큐가 하나여서 모든 프로세스는 우선순위가 동일하다.

> 콘보이 효과: 앞에서 처리 시간이 긴 프로세스가 차지해서 뒤에 있는 CPU들은 하염없이 기다려야 돼서 효율성이 떨어지는 문제

<br>

## SJF(Shortest Job First)
---
SJF는 준비 큐에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식이다.

![27](/assets/os/27.png)

SJF는 시스템 효율성이 FCFS보다는 좋아지지만 두 가지의 문제가 발생한다.

1. 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 힘들다.
- 현재 들어가있는 프로세스와 뒤에 있는 프로세스 중에 누가 더 빨리 끝나는지 알기가 힘들다. 프로세스도 자신이 얼마나 오랫동안 작업을 할것인지 알기가 힘들다.

2. 공평하지 못하다.
- 먼저 준비 큐에 들어왔지만 지속적으로 더 짧은 것들이 들어오면 먼저 들어온 큐는 `Starvation` 또는 `infinite blocking`이 발생한다. `Starvation`은 짧은 프로세스가 영원히 들어온다고 가정했을 때, 영원히 처리되지 못해서 굶어 죽는다는 뜻이다.

<br>

## HRN(Highest Response Ratio Next)
---
HRN은 SJF 스케줄링에서 발생하는 `starvation`을 해결하기 위해 만들어진 비선점형 알고리즘이다.

![28](/assets/os/28.png)

위의 식을 보면 대기시간이 길어질수록 우선순위는 높아지는 것을 알 수 있다.

<br>

## 라운드 로빈 스케줄링(Round Robin)
---
라운드 로빈은 한 프로세스가 할당받은 시간 동안만 작업을 하고 완료하지 못하면 준비 큐의 맨뒤로 가서 다시 차례를 기다린다.

![29](/assets/os/29.png)

```라운드 로빈 스케줄링은 문맥 교환이 발생하므로 타임 슬라이스를 적절하게 설정해야 한다.```

<br>

## SRT(Shortest Remaining Time)
---
SJF와 라운드로빈이 혼합된 방식으로, 기본적으로 라운드 로빈 방식을 사용하지만 CPU를 할당받을 때 작업 시간이 가장 적은 프로세스를 선택한다.

![30](/assets/os/30.png)

하지만 SJF와 마찬가지로 프로세스의 종료 시간을 예측하기 어렵고 `starvation`이 발생할 확률이 높다.

<br>

## 우선순위 스케줄링
---
프로세스 중요도에 따라 우선순위를 설정한다.

하지만, 준비 큐에 있는 프로세스의 순서를 무시하고 우선순위에 따라 매번 바꿔야 해서 오버헤드가 커지므로 시스템 효율을 떨어뜨린다.

<br>

## 다단계 큐 스케줄링(multilevel queue) 와 피드백 큐 스케줄링
---
우선순위에 따라 준비 큐를 여러 개 사용하고, 각각의 큐는 라운드 로빈 방식으로 운영된다.

![31](/assets/os/31.png)

문제는 하위 우선순위 큐의 프로세스들은 상위 우선순위 큐의 프로세스들이 모두 끝나야 할당이 된다는 점이다.

이를 해결하기 위해 나온것이 바로 `다단계 피드백 큐(multilevel feedback queue)`인데 피드백 큐는 타임슬라이스 만큼 프로세스를 처리하고 남은 프로세스는 같은 우선순위 큐의 뒤로 가는 것이 아니라 하나 낮은 우선순위 큐의 끝으로 들어가게 된다.

> ```아무리 우선순위가 낮아져도 커널 프로세스가 일반 프로레스 큐로 삽입되지는 않는다!!!```

피드백 큐의 또 다른 특징으로 하위 우선순위 큐일수록 타임 슬라이스가 커서 실행 기회를 조금 더 부여한다.
- 맨 마지막 큐에 있는 프로세스는 무한대의 타임 슬라이스를 얻어서 프로세스가 종료될때까지 리소스를 얻는다.

<br>

# 인터럽트
---
초기의 컴퓨터는 입출력장치가 거의 없어서 입출력을 요청하면 운영체제가 주기적으로 입출력장치를 직접 확인해서 처리했는데 이 방식을 `폴링`이라고 부른다.

하지만, 입출력장치가 증가하면서 `폴링`방식을 사용하기가 어려워졌고 입출력을 요청하고 입출력이 완료되면 이벤트를 발생시키는데 이것은 `인터럽트`라고 한다.

> 인터럽트는 입출력 뿐만 아니라 매우 종류가 다양하다!!

<br>

## 동기(synchronous), 비동기(asynchronous) 인터럽트
---
인터럽트는 프로세스가 실행 중인 명령어로 인해 발생하는 동기적 인터럽트와 명령어와 무관하게 발생하는 비동기적 인터럽트로 나뉜다.

동기적의 예
- 프로그램상의 문제
- 작업자가 의도적으로 프로세스를 중단
- 입출력 장치
- 산술 연산 중 발생하는 예외

비동기적의 예
- 하드디스크 읽기 오류
- 메모리 불량
- 하드웨어적인 오류

<br>

## 처리과정
---
인터럽트가 발생하면 해당 인터럽트 고유 번호와 해당 인터럽트를 처리하는 함수인 `인터럽트 핸들러`가 저장되어 있어서 그에 맞게 처리된다.

인터럽트는 보통 동시에 여러개가 발생하기도 해서 인터럽트를 묶어서 처리를 하는데 이것을 `인터럽트 벡터`라고 한다.

여기서 사용자 모드와 커널 모드를 오가며 작업이 이루어지는데, 커널이 제공하는 시스템 콜을 효율적으로 사용하기 위해 `API(Application Programming Interface)`를 사용한다.

과정을 정리해보자면 다음과 같다.

1. 인터럽트가 발생하면 현재 실행중인 프로세스는 일시 정지 상태가 되며, 재시작하기 위해 현재 프로세스 정보를 임시 저장한다.

2. 인터럽트 컨트롤러가 실행되어 처리 순서를 결정하고, 여러 개라면 우선순위를 고려해서 순서를 결정한다.

3. 인터럽트 벡터에서 인터럽트 번호와 1대1로 매핑된 인터럽트 핸들러가 실행된다.

4. 핸들러가 인터럽트 처리를 마치면 정지된 프로세스가 다시 실행되거나 종료된다.